pub mod openapi_joiner {
    use std::ffi::OsStr;
    use std::path::PathBuf;

    use chrono::Utc;
    use indexmap::{indexmap, IndexMap};
    use openapiv3::{
        AdditionalProperties, AnySchema, ArrayType, Callback, Components, Encoding, Example,
        Header, Info, MediaType, ObjectType, OpenAPI, Operation, Parameter, ParameterData,
        ParameterSchemaOrContent, PathItem, Paths, ReferenceOr, RequestBody, Response, Responses,
        Schema, SchemaKind, SecurityRequirement, StatusCode, Tag, Type,
    };

    pub struct OpenAPIJoiner {
        pub joined: OpenAPI,
        cors_options: Option<Operation>,
    }

    impl OpenAPIJoiner {
        pub fn new() -> OpenAPIJoiner {
            let cors_response = ReferenceOr::Item(Response {
                description: "204 response".to_string(),
                ..Default::default()
            });
            let responses = indexmap! {
            StatusCode::Code(200)=>cors_response.clone(),
            StatusCode::Code(204)=>cors_response.clone(),};
            OpenAPIJoiner {
                joined: OpenAPI {
                    openapi: "3.0.0".to_string(),
                    info: Info {
                        title: "Consolidated OpenAPI specifications for the Apigee WAF".to_string(),
                        description: Some(
                            "This is a consolidated OpenAPI specification for the Apigee WAF. It \
                             is generated by the `openapi-cat` tool."
                                .to_string(),
                        ),
                        version: Utc::now().to_string(),
                        ..Default::default()
                    },
                    paths: Paths {
                        paths: IndexMap::new(),
                        extensions: IndexMap::new(),
                    },
                    components: Some(Components {
                        security_schemes: IndexMap::new(),
                        responses: IndexMap::new(),
                        parameters: IndexMap::new(),
                        examples: IndexMap::new(),
                        request_bodies: IndexMap::new(),
                        headers: IndexMap::new(),
                        schemas: IndexMap::new(),
                        links: IndexMap::new(),
                        callbacks: IndexMap::new(),
                        extensions: IndexMap::new(),
                    }),
                    ..Default::default()
                },
                cors_options: Some(Operation {
                    tags: vec!["auto_cors".to_string()],
                    description: Some("CORS support".to_string()),
                    responses: Responses {
                        responses,
                        ..Default::default()
                    },
                    ..Default::default()
                }),
            }
        }
        pub fn add(&mut self, input: OpenAPI, base_path: &str, prefix: &str) {
            if input.openapi.cmp(&self.joined.openapi) == std::cmp::Ordering::Greater {
                self.joined.openapi = input.openapi;
            }
            let adjusted_paths = self.adjust_paths(&input.paths, base_path, prefix);
            self.joined.paths.paths.extend(adjusted_paths.paths);
            self.joined
                .paths
                .extensions
                .extend(adjusted_paths.extensions);
            let adjusted_components = self.adjust_components(input.components, prefix);
            self.add_components(adjusted_components);
            self.adjust_security_requirements(input.security, prefix);
            self.adjust_tags_definition(input.tags, prefix);
        }

        pub fn write_to(&self, filepath: &str) {
            if filepath == "-" {
                self.write_to_stdout();
            } else {
                self.write_to_file(filepath);
            }
        }

        pub fn write_to_stdout(&self) {
            serde_json::to_writer(std::io::stdout(), &self.joined)
                .expect("Could not write to stdout");
            println!()
        }

        pub fn write_to_file(&self, filepath: &str) {
            let extension = PathBuf::from(filepath)
                .extension()
                .and_then(OsStr::to_str)
                .and_then(|ext| Some(ext.to_lowercase()));
            match extension {
                Some(ext) => match ext.as_str() {
                    "yaml" => serde_yaml::to_writer(
                        std::fs::File::create(filepath).expect("Could not create file"),
                        &self.joined,
                    )
                    .expect("Could not write to file"),
                    "json" => serde_json::to_writer(
                        std::fs::File::create(filepath).expect("Could not create file"),
                        &self.joined,
                    )
                    .expect("Could not write to file"),
                    _ => panic!("Unsupported file extension {}", ext),
                },
                None => panic!("Could not determine file extension"),
            }
        }
        fn adjust_path_item_ref(
            &mut self,
            item: &ReferenceOr<PathItem>,
            prefix: &str,
        ) -> ReferenceOr<PathItem> {
            match item {
                ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                    reference: self.fix_reference(reference.as_str(), prefix).to_string(),
                },
                ReferenceOr::Item(path_item) => {
                    let new_item: PathItem = self.adjust_path_item(&path_item, prefix);
                    ReferenceOr::Item(new_item)
                }
            }
        }
        fn adjust_path_item(&mut self, path_item: &PathItem, prefix: &str) -> PathItem {
            PathItem {
                get: self.adjust_operation(&path_item.get, prefix),
                put: self.adjust_operation(&path_item.put, prefix),
                post: self.adjust_operation(&path_item.post, prefix),
                delete: self.adjust_operation(&path_item.delete, prefix),
                options: self.cors_options.clone(),
                head: self.adjust_operation(&path_item.head, prefix),
                patch: self.adjust_operation(&path_item.patch, prefix),
                trace: self.adjust_operation(&path_item.trace, prefix),
                parameters: self.adjust_parameters(&path_item.parameters, prefix),
                summary: path_item.summary.clone(),
                description: path_item.description.clone(),
                servers: Vec::new(),
                extensions: self.adjust_key_in_map(&path_item.extensions, prefix),
            }
        }
        fn fix_reference(&mut self, reference: &str, prefix: &str) -> String {
            let mut parts: Vec<&str> = reference.split('/').collect();
            let last = parts.pop().unwrap();
            let new_last = format!("{}_{}", prefix, last);
            parts.push(new_last.as_str());
            parts.join("/")
        }
        fn adjust_operation(
            &mut self,
            operation: &Option<Operation>,
            prefix: &str,
        ) -> Option<Operation> {
            match operation {
                Some(op) => Some(Operation {
                    tags: self.adjust_tags(&op.tags, prefix),
                    summary: op.summary.clone(),
                    description: op.description.clone(),
                    external_docs: op.external_docs.clone(),
                    operation_id: self.fix_operation_id(&op.operation_id, prefix),
                    parameters: self.adjust_parameters(&op.parameters, prefix),
                    request_body: self.adjust_request_body_opt_ref(&op.request_body, prefix),
                    responses: self.fix_responses(op.responses.clone(), prefix),
                    deprecated: op.deprecated,
                    security: self.adjust_security(&op.security, prefix),
                    servers: Vec::new(),
                    extensions: self.adjust_key_in_map(&op.extensions, prefix),
                }),
                None => None,
            }
        }
        fn adjust_parameters(
            &mut self,
            parameters: &Vec<ReferenceOr<Parameter>>,
            prefix: &str,
        ) -> Vec<ReferenceOr<Parameter>> {
            parameters
                .iter()
                .map(|param| match param {
                    ReferenceOr::Reference { reference } => {
                        let new_ref = self.fix_reference(reference.as_str(), prefix);
                        ReferenceOr::Reference { reference: new_ref }
                    }
                    ReferenceOr::Item(param_item) => {
                        let new_param = self.adjust_parameter(param_item, prefix);
                        ReferenceOr::Item(new_param)
                    }
                })
                .collect()
        }
        fn adjust_parameter(&mut self, parameter: &Parameter, prefix: &str) -> Parameter {
            match parameter {
                Parameter::Query {
                    parameter_data,
                    allow_reserved,
                    style,
                    allow_empty_value,
                } => Parameter::Query {
                    parameter_data: self.adjust_parameter_data(parameter_data, prefix),
                    allow_reserved: *allow_reserved,
                    style: style.clone(),
                    allow_empty_value: *allow_empty_value,
                },
                Parameter::Header {
                    parameter_data,
                    style,
                } => Parameter::Header {
                    parameter_data: self.adjust_parameter_data(parameter_data, prefix),
                    style: style.clone(),
                },
                Parameter::Path {
                    parameter_data,
                    style,
                } => Parameter::Path {
                    parameter_data: self.adjust_parameter_data(parameter_data, prefix),
                    style: style.clone(),
                },
                Parameter::Cookie {
                    parameter_data,
                    style,
                } => Parameter::Cookie {
                    parameter_data: self.adjust_parameter_data(parameter_data, prefix),
                    style: style.clone(),
                },
            }
        }
        fn adjust_parameter_data(
            &mut self,
            parameter_data: &ParameterData,
            prefix: &str,
        ) -> ParameterData {
            ParameterData {
                name: parameter_data.name.clone(),
                description: parameter_data.description.clone(),
                required: parameter_data.required,
                deprecated: parameter_data.deprecated,
                explode: parameter_data.explode,
                example: parameter_data.example.clone(),
                examples: self.adjust_examples(&parameter_data.examples, prefix),
                extensions: self.adjust_key_in_map(&parameter_data.extensions, prefix),
                format: self.adjust_schema_or_content(&parameter_data.format, prefix),
            }
        }
        fn adjust_examples(
            &mut self,
            examples: &IndexMap<String, ReferenceOr<Example>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<Example>> {
            examples
                .iter()
                .map(|(key, value)| {
                    let new_key = key.clone();
                    let new_value = self.adjust_reference(value, prefix);
                    (new_key, new_value)
                })
                .collect()
        }
        fn fix_operation_id(
            &mut self,
            operation_id: &Option<String>,
            prefix: &str,
        ) -> Option<String> {
            match operation_id {
                Some(id) => Some(prefix.to_string() + "_" + id.as_str()),
                None => None,
            }
        }
        fn fix_responses(&mut self, responses: Responses, prefix: &str) -> Responses {
            Responses {
                default: match responses.default {
                    None => None,
                    Some(response) => Some(self.fix_reference_or_response(response, prefix)),
                },
                responses: responses
                    .responses
                    .iter()
                    .map(|(key, value)| {
                        let new_key = key.clone();
                        let new_value = self.fix_reference_or_response(value.clone(), prefix);
                        (new_key, new_value)
                    })
                    .collect(),
                extensions: self.adjust_key_in_map(&responses.extensions, prefix),
            }
        }
        fn fix_reference_or_response(
            &mut self,
            ref_or_response: ReferenceOr<Response>,
            prefix: &str,
        ) -> ReferenceOr<Response> {
            match ref_or_response {
                ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                    reference: self.fix_reference(reference.as_str(), prefix),
                },
                ReferenceOr::Item(response) => {
                    let new_response = Response {
                        description: response.description,
                        headers: response.headers, //fixme
                        content: self.adjust_content(&response.content, prefix),
                        links: self.adjust_reference_in_map(&response.links, prefix),
                        extensions: self.adjust_key_in_map(&response.extensions, prefix),
                    };
                    ReferenceOr::Item(new_response)
                }
            }
        }
        fn adjust_content(
            &mut self,
            content: &IndexMap<String, MediaType>,
            prefix: &str,
        ) -> IndexMap<String, MediaType> {
            content
                .iter()
                .map(|(key, value)| {
                    let new_key = key.clone();
                    let new_value = MediaType {
                        schema: match value.schema.clone() {
                            None => None,
                            Some(schema) => Some(self.fix_reference_or_schema(schema, prefix)),
                        },
                        example: value.example.clone(),
                        examples: self.adjust_examples(&value.examples, prefix),
                        encoding: value
                            .encoding
                            .iter()
                            .map(|(key, value)| {
                                let new_key = key.clone();
                                let new_value = Encoding {
                                    content_type: value.content_type.clone(),
                                    headers: self.adjust_headers(&value.headers, prefix),
                                    style: value.style.clone(),
                                    explode: value.explode,
                                    allow_reserved: value.allow_reserved,
                                    extensions: value.extensions.clone(),
                                };
                                (new_key, new_value)
                            })
                            .collect(),
                        extensions: self.adjust_key_in_map(&value.extensions, prefix),
                    };
                    (new_key, new_value)
                })
                .collect()
        }
        fn fix_reference_or_schema(
            &mut self,
            schema: ReferenceOr<Schema>,
            prefix: &str,
        ) -> ReferenceOr<Schema> {
            match schema {
                ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                    reference: self.fix_reference(reference.as_str(), prefix),
                },
                ReferenceOr::Item(schema) => ReferenceOr::Item(self.adjust_schema(&schema, prefix)),
            }
        }
        fn adjust_schema(&mut self, schema: &Schema, prefix: &str) -> Schema {
            Schema {
                schema_data: schema.schema_data.clone(),
                schema_kind: self.adjust_schema_kind(schema.schema_kind.clone(), prefix),
            }
        }
        fn adjust_headers(
            &mut self,
            headers: &IndexMap<String, ReferenceOr<Header>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<Header>> {
            headers
                .iter()
                .map(|(key, value)| {
                    let new_key = key.clone();
                    let new_value = match value {
                        ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                            reference: self.fix_reference(reference.as_str(), prefix),
                        },
                        ReferenceOr::Item(header) => ReferenceOr::Item(Header {
                            description: header.description.clone(),
                            style: header.style.clone(),
                            required: header.required,
                            deprecated: header.deprecated,
                            format: header.format.clone(),
                            example: header.example.clone(),
                            examples: self.adjust_examples(&header.examples, prefix),
                            extensions: self.adjust_key_in_map(&header.extensions, prefix),
                        }),
                    };
                    (new_key, new_value)
                })
                .collect()
        }
        fn adjust_schema_kind(&mut self, schema_kind: SchemaKind, prefix: &str) -> SchemaKind {
            match schema_kind {
                SchemaKind::Type(t) => SchemaKind::Type(self.adjust_type(t, prefix)),
                SchemaKind::OneOf { one_of } => SchemaKind::OneOf {
                    one_of: self.adjust_schemas(one_of, prefix),
                },
                SchemaKind::AllOf { all_of } => SchemaKind::AllOf {
                    all_of: self.adjust_schemas(all_of, prefix),
                },
                SchemaKind::AnyOf { any_of } => SchemaKind::AnyOf {
                    any_of: self.adjust_schemas(any_of, prefix),
                },
                SchemaKind::Not { not } => SchemaKind::Not {
                    not: Box::new(self.fix_reference_or_schema(*not, prefix)),
                },
                SchemaKind::Any(any) => SchemaKind::Any(AnySchema {
                    typ: any.typ,
                    pattern: any.pattern,
                    multiple_of: any.multiple_of,
                    exclusive_minimum: any.exclusive_minimum,
                    exclusive_maximum: any.exclusive_maximum,
                    minimum: any.minimum,
                    maximum: any.maximum,
                    properties: self.adjust_properties(any.properties, prefix),
                    required: any.required,
                    additional_properties: self
                        .adjust_additional_properties(any.additional_properties, prefix),
                    min_properties: any.min_properties,
                    max_properties: any.max_properties,
                    items: self.adjust_schema_refs(any.items, prefix),
                    min_items: any.min_items,
                    max_items: any.max_items,
                    unique_items: any.unique_items,
                    enumeration: any.enumeration,
                    format: any.format,
                    min_length: any.min_length,
                    max_length: any.max_length,
                    one_of: self.adjust_schemas(any.one_of, prefix),
                    all_of: self.adjust_schemas(any.all_of, prefix),
                    any_of: self.adjust_schemas(any.any_of, prefix),
                    not: match any.not {
                        None => None,
                        Some(not) => Some(Box::new(self.fix_reference_or_schema(*not, prefix))),
                    },
                }),
            }
        }
        fn adjust_schemas(
            &mut self,
            schemas: Vec<ReferenceOr<Schema>>,
            p1: &str,
        ) -> Vec<ReferenceOr<Schema>> {
            schemas
                .iter()
                .map(|schema| self.fix_reference_or_schema(schema.clone(), p1))
                .collect()
        }
        /// adjust component schemas or schema references
        fn adjust_properties(
            &mut self,
            properties: IndexMap<String, ReferenceOr<Box<Schema>>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<Box<Schema>>> {
            properties
                .iter()
                .map(|(key, value)| {
                    let new_key = key.clone();
                    let new_value = match value {
                        ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                            reference: self.fix_reference(reference.as_str(), prefix),
                        },
                        ReferenceOr::Item(schema) => {
                            ReferenceOr::Item(Box::new(self.adjust_schema(&*schema, prefix)))
                        }
                    };
                    (new_key, new_value)
                })
                .collect()
        }
        /// adjust an element that may contain additional properties
        fn adjust_additional_properties(
            &mut self,
            props: Option<AdditionalProperties>,
            prefix: &str,
        ) -> Option<AdditionalProperties> {
            match props {
                None => None,
                Some(additional_properties) => match additional_properties {
                    AdditionalProperties::Any(b) => Some(AdditionalProperties::Any(b)),
                    AdditionalProperties::Schema(schema_ref_ptr) => {
                        let schema_ref = *schema_ref_ptr;
                        let new_schema_ref =
                            Box::new(self.fix_reference_or_schema(schema_ref, prefix));
                        Some(AdditionalProperties::Schema(new_schema_ref))
                    }
                },
            }
        }
        /// adjust an element that may contain a schema definition or a reference to a schema definition
        fn adjust_schema_refs(
            &mut self,
            schema_refs: Option<ReferenceOr<Box<Schema>>>,
            prefix: &str,
        ) -> Option<ReferenceOr<Box<Schema>>> {
            match schema_refs {
                None => None,
                Some(item) => match item {
                    ReferenceOr::Reference { reference } => {
                        println!("adjust_items: reference: {}", reference);
                        Some(ReferenceOr::Reference {
                            reference: self.fix_reference(reference.as_str(), prefix),
                        })
                    }
                    ReferenceOr::Item(schema_ptr) => {
                        let schema = *schema_ptr;
                        let new_schema = Box::new(self.adjust_schema(&schema, prefix));
                        Some(ReferenceOr::Item(new_schema))
                    }
                },
            }
        }
        /// adjust the components of the document, so that they have distinct ids.
        fn adjust_components(
            &mut self,
            components: Option<Components>,
            prefix: &str,
        ) -> Option<Components> {
            match components {
                None => None,
                Some(comps) => {
                    let new_comps = Components {
                        schemas: self.adjust_map_schemas(&comps.schemas, prefix),
                        responses: self.adjust_response_ref(&comps.responses, prefix),
                        parameters: self.adjust_parameter_map(&comps.parameters, prefix),
                        examples: self.adjust_examples(&comps.examples, prefix),
                        request_bodies: self.adjust_request_bodies(&comps.request_bodies, prefix),
                        headers: self.adjust_headers(&comps.headers, prefix),
                        security_schemes: self
                            .adjust_reference_in_map(&comps.security_schemes, prefix),
                        links: self.adjust_reference_in_map(&comps.links, prefix),
                        callbacks: self.adjust_callback_map(&comps.callbacks, prefix),
                        extensions: self.adjust_key_in_map(&comps.extensions, prefix),
                    };
                    Some(new_comps)
                }
            }
        }
        /// adjust the component schemas.
        fn adjust_map_schemas(
            &mut self,
            schemas: &IndexMap<String, ReferenceOr<Schema>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<Schema>> {
            schemas
                .iter()
                .map(|(key, value)| {
                    let new_key = prefix.to_string() + "_" + key;
                    let new_value = self.adjust_reference_or_schema(value, prefix);
                    (new_key, new_value)
                })
                .collect()
        }
        /// adjust an element that is a reference to a schema or a schema.
        fn adjust_reference_or_schema(
            &mut self,
            value: &ReferenceOr<Schema>,
            prefix: &str,
        ) -> ReferenceOr<Schema> {
            match value {
                ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                    reference: self.fix_reference(reference.as_str(), prefix),
                },
                ReferenceOr::Item(schema) => ReferenceOr::Item(self.adjust_schema(schema, prefix)),
            }
        }
        /// adjust an element that is a reference to a response or a response.
        fn adjust_response_ref(
            &mut self,
            response_ref: &IndexMap<String, ReferenceOr<Response>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<Response>> {
            response_ref
                .iter()
                .map(|(key, value)| {
                    let new_key = prefix.to_string() + "_" + key;
                    let new_value = match value {
                        ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                            reference: self.fix_reference(reference.as_str(), prefix),
                        },
                        ReferenceOr::Item(response) => {
                            ReferenceOr::Item(self.adjust_response(response, prefix))
                        }
                    };
                    (new_key, new_value)
                })
                .collect()
        }
        /// Adjusts a response.
        fn adjust_response(&mut self, response: &Response, prefix: &str) -> Response {
            Response {
                description: response.description.clone(),
                headers: self.adjust_headers(&response.headers, prefix),
                content: self.adjust_content(&response.content, prefix),
                links: self.adjust_reference_in_map(&response.links, prefix),
                extensions: self.adjust_key_in_map(&response.extensions, prefix),
            }
        }
        /// Adjusts a parameter type if it is an array or object, leaving other types unchanged.
        fn adjust_type(&mut self, typ: Type, prefix: &str) -> Type {
            match typ {
                Type::Array(arr) => Type::Array(ArrayType {
                    items: match arr.items {
                        None => None,
                        Some(item) => match item {
                            ReferenceOr::Reference { reference } => Some(ReferenceOr::ref_(
                                self.fix_reference(reference.as_str(), prefix).as_str(),
                            )),
                            ReferenceOr::Item(item_schema) => Some(ReferenceOr::boxed_item(
                                self.adjust_schema(&*item_schema, prefix),
                            )),
                        },
                    },
                    min_items: arr.min_items,
                    max_items: arr.max_items,
                    unique_items: arr.unique_items,
                }),
                Type::Object(obj_type) => Type::Object(ObjectType {
                    properties: self.adjust_properties(obj_type.properties, prefix),
                    additional_properties: self
                        .adjust_additional_properties(obj_type.additional_properties, prefix),
                    required: obj_type.required.clone(),
                    min_properties: obj_type.min_properties,
                    max_properties: obj_type.max_properties,
                }),
                _ => typ,
            }
        }
        /// Add (adjusted) components to the merged spec
        fn add_components(&mut self, components: Option<Components>) {
            if let Some(comps) = components {
                let my_components = self.joined.components.as_mut().unwrap();
                my_components.schemas.extend(comps.schemas);
                my_components.responses.extend(comps.responses);
                my_components.parameters.extend(comps.parameters);
                my_components.examples.extend(comps.examples);
                my_components.request_bodies.extend(comps.request_bodies);
                my_components.headers.extend(comps.headers);
                my_components
                    .security_schemes
                    .extend(comps.security_schemes);
                my_components.links.extend(comps.links);
                my_components.callbacks.extend(comps.callbacks);
                my_components.extensions.extend(comps.extensions);
            }
        }
        /// Adjusts the paths in the spec
        fn adjust_paths(&mut self, paths: &Paths, base_path: &str, prefix: &str) -> Paths {
            Paths {
                paths: paths
                    .paths
                    .iter()
                    .map(|(path, path_item)| {
                        let new_path = base_path.to_string() + path;
                        let new_path_item = self.adjust_path_item_ref(path_item, prefix);
                        (new_path, new_path_item)
                    })
                    .collect(),
                extensions: self.adjust_key_in_map(&paths.extensions, prefix),
            }
        }
        fn adjust_parameter_map(
            &mut self,
            parameters: &IndexMap<String, ReferenceOr<Parameter>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<Parameter>> {
            parameters
                .iter()
                .map(|(key, value)| {
                    let new_key = prefix.to_string() + "_" + key;
                    let new_value = match value {
                        ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                            reference: self.fix_reference(reference.as_str(), prefix),
                        },
                        ReferenceOr::Item(parameter) => {
                            ReferenceOr::Item(self.adjust_parameter(parameter, prefix))
                        }
                    };
                    (new_key, new_value)
                })
                .collect()
        }

        fn adjust_security_requirements(
            &mut self,
            security_requirement: Option<Vec<SecurityRequirement>>,
            prefix: &str,
        ) {
            let adjusted_security = self.adjust_security(&security_requirement, prefix);
            match adjusted_security {
                Some(security_requirement) => self
                    .joined
                    .security
                    .as_mut()
                    .unwrap()
                    .extend(security_requirement),
                None => (),
            }
        }
        fn adjust_security(
            &mut self,
            security_requirement: &Option<Vec<SecurityRequirement>>,
            prefix: &str,
        ) -> Option<Vec<SecurityRequirement>> {
            match security_requirement {
                None => None,
                Some(security_requirement) => Some(
                    security_requirement
                        .iter()
                        .map(|security| self.adjust_key_in_map(security, prefix))
                        .collect(),
                ),
            }
        }
        fn adjust_reference<T: Clone>(
            &mut self,
            reference_or: &ReferenceOr<T>,
            prefix: &str,
        ) -> ReferenceOr<T> {
            match reference_or {
                ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                    reference: self.fix_reference(reference.as_str(), prefix),
                },
                ReferenceOr::Item(item) => ReferenceOr::Item(item.clone()),
            }
        }
        fn adjust_reference_in_map<T: Clone>(
            &mut self,
            map: &IndexMap<String, ReferenceOr<T>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<T>> {
            map.iter()
                .map(|(key, value)| {
                    let new_key = prefix.to_string() + "_" + key;
                    let new_value = self.adjust_reference(value, prefix);
                    (new_key, new_value)
                })
                .collect()
        }
        fn adjust_request_body_opt_ref(
            &mut self,
            request_bodies: &Option<ReferenceOr<RequestBody>>,
            prefix: &str,
        ) -> Option<ReferenceOr<RequestBody>> {
            match request_bodies {
                None => None,
                Some(request_bodies) => {
                    let new_request_bodies = self.adjust_request_body_ref(request_bodies, prefix);
                    Some(new_request_bodies)
                }
            }
        }
        fn adjust_request_body(&mut self, request_body: &RequestBody, prefix: &str) -> RequestBody {
            RequestBody {
                description: request_body.description.clone(),
                content: self.adjust_content(&request_body.content, prefix),
                required: request_body.required,
                extensions: self.adjust_key_in_map(&request_body.extensions, prefix),
            }
        }
        fn adjust_tags(&self, tags: &Vec<String>, prefix: &str) -> Vec<String> {
            match tags.is_empty() {
                true => vec![prefix.to_string()],
                false => tags
                    .iter()
                    .map(|tag| prefix.to_string() + "_" + tag)
                    .collect(),
            }
        }
        fn adjust_tags_definition(&mut self, tags: Vec<Tag>, prefix: &str) {
            tags.iter()
                .map(|tag| {
                    let new_tag = Tag {
                        name: prefix.to_string() + "_" + &tag.name,
                        description: tag.description.clone(),
                        external_docs: tag.external_docs.clone(),
                        extensions: self.adjust_key_in_map(&tag.extensions, prefix),
                    };
                    self.joined.tags.push(new_tag);
                })
                .collect()
        }
        fn adjust_callback_map(
            &mut self,
            callbacks: &IndexMap<String, ReferenceOr<Callback>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<Callback>> {
            callbacks
                .iter()
                .map(|(key, value)| {
                    let new_key = prefix.to_string() + "_" + key;
                    let new_value = self.adjust_callback_ref(value, prefix);
                    (new_key, new_value)
                })
                .collect()
        }
        fn adjust_callback_ref(
            &mut self,
            callback: &ReferenceOr<Callback>,
            prefix: &str,
        ) -> ReferenceOr<Callback> {
            match callback {
                ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                    reference: self.fix_reference(reference.as_str(), prefix),
                },
                ReferenceOr::Item(callback) => {
                    let new_callback = callback
                        .iter()
                        .map(|(key, value)| {
                            let new_key = prefix.to_string() + "_" + key;
                            let new_value = self.adjust_path_item(&value, prefix);
                            (new_key, new_value)
                        })
                        .collect();
                    ReferenceOr::Item(new_callback)
                }
            }
        }
        fn adjust_key_in_map<T: Clone>(
            &mut self,
            map: &IndexMap<String, T>,
            prefix: &str,
        ) -> IndexMap<String, T> {
            map.iter()
                .map(|(key, value)| {
                    let new_key = prefix.to_string() + "_" + key;
                    let new_value = value.clone();
                    (new_key, new_value)
                })
                .collect()
        }
        fn adjust_request_bodies(
            &mut self,
            request_bodies: &IndexMap<String, ReferenceOr<RequestBody>>,
            prefix: &str,
        ) -> IndexMap<String, ReferenceOr<RequestBody>> {
            request_bodies
                .iter()
                .map(|(key, value)| {
                    let new_key = prefix.to_string() + "_" + key;
                    let new_value = self.adjust_request_body_ref(value, prefix);
                    (new_key, new_value)
                })
                .collect()
        }

        fn adjust_request_body_ref(
            &mut self,
            value: &ReferenceOr<RequestBody>,
            prefix: &str,
        ) -> ReferenceOr<RequestBody> {
            match value {
                ReferenceOr::Reference { reference } => ReferenceOr::Reference {
                    reference: self.fix_reference(reference.as_str(), prefix),
                },
                ReferenceOr::Item(request_body) => {
                    ReferenceOr::Item(self.adjust_request_body(request_body, prefix))
                }
            }
        }
        fn adjust_schema_or_content(
            &mut self,
            schema_or_content: &ParameterSchemaOrContent,
            prefix: &str,
        ) -> ParameterSchemaOrContent {
            match schema_or_content {
                ParameterSchemaOrContent::Schema(schema_or_reference) => {
                    ParameterSchemaOrContent::Schema(
                        self.adjust_reference_or_schema(schema_or_reference, prefix),
                    )
                }
                ParameterSchemaOrContent::Content(content) => {
                    ParameterSchemaOrContent::Content(self.adjust_content(content, prefix))
                }
            }
        }
    }
}
